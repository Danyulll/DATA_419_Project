density2 <- matrix(pdf_values2, nrow = length(x))
# density3 <- matrix(pdf_values3, nrow = length(x))
plot1 <-
plot_ly(
x = x,
y = y,
z = density1,
type = "surface",
colors = "viridis",
opacity = 1
)|> add_surface(
x = x,
y = y,
z = density3,
colors = "viridis",
opacity = 1
) |> add_markers(
data = dgp,
x = dgp$X1,
y = dgp$X2,
z = 0,
opacity=1
) |> add_markers(
x = grid$X1,
y = grid$X2,
z = 0,
color=~prd,
opacity=0.01
)
lda.out <- lda(G~.,dgp)
prd = as.numeric(predict(lda.out, newdata = grid)$class)
plot1
shiny::runApp()
runApp()
library(klaR)
library(mvtnorm)
set.seed(231354)
sigma1 <- matrix(c(1, 0, 0, 1), 2, 2, byrow = TRUE)
mu1 <- c(0, 0)
mu2 <- c(0, 2)
# Generate 2D MVN data from 1 group so one MVN
group1 <- data.frame(rmvnorm(100, mean = mu1, sigma = sigma1))
# Generate more 2D MVN from a different dist, that's group 2.
group2 <- data.frame(rmvnorm(100, mean = mu2, sigma = sigma1))
groups <- c(rep("G1", 100), rep("G2", 100))
dgp <-
data.frame(
"G" = groups,
"X1" = c(group1$X1, group2$X1),
"X2" = c(group1$X2, group2$X2)
)
# Now I can plot the underlying densities that generated them (this is not the same thing as plotting the points). Make the densities see through
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
grid <- expand.grid(x = x, y = y)
colnames(grid) <- colnames(xdat)[-1]
# Calculate the probability density for each point on the grid for both Gaussians
pdf_values1 <- dmvnorm(grid, mean = mu1, sigma = sigma1)
pdf_values2 <- dmvnorm(grid, mean = mu2, sigma = sigma1)
# Reshape the density values to match the grid
density1 <- matrix(pdf_values1, nrow = length(x))
density2 <- matrix(pdf_values2, nrow = length(x))
lda.out <- lda(G~.,dgp)
prd = as.numeric(predict(lda.out, newdata = grid)$class)
plot1 <-
plot_ly(
x = x,
y = y,
z = density1,
type = "surface",
colors = "viridis",
opacity = 0.5
)|> add_surface(
x = x,
y = y,
z = density3,
colors = "viridis",
opacity = 0.5
) |> add_markers(
data = dgp,
x = dgp$X1,
y = dgp$X2,
z = 0,
opacity=1
) |> add_markers(
x = grid$X1,
y = grid$X2,
z = 0,
color=~prd,
opacity=0.01
)
plot1
library(klaR)
library(mvtnorm)
set.seed(231354)
sigma1 <- matrix(c(1, 0, 0, 1), 2, 2, byrow = TRUE)
mu1 <- c(0, 0)
mu2 <- c(0, 2)
# Generate 2D MVN data from 1 group so one MVN
group1 <- data.frame(rmvnorm(100, mean = mu1, sigma = sigma1))
# Generate more 2D MVN from a different dist, that's group 2.
group2 <- data.frame(rmvnorm(100, mean = mu2, sigma = sigma1))
groups <- c(rep("G1", 100), rep("G2", 100))
dgp <-
data.frame(
"G" = groups,
"X1" = c(group1$X1, group2$X1),
"X2" = c(group1$X2, group2$X2)
)
# Now I can plot the underlying densities that generated them (this is not the same thing as plotting the points). Make the densities see through
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
grid <- expand.grid(x = x, y = y)
colnames(grid) <- colnames(xdat)[-1]
# Calculate the probability density for each point on the grid for both Gaussians
pdf_values1 <- dmvnorm(grid, mean = mu1, sigma = sigma1)
pdf_values2 <- dmvnorm(grid, mean = mu2, sigma = sigma1)
# Reshape the density values to match the grid
density1 <- matrix(pdf_values1, nrow = length(x))
density2 <- matrix(pdf_values2, nrow = length(x))
lda.out <- lda(G~.,dgp)
prd = as.numeric(predict(lda.out, newdata = grid)$class)
plot1 <-
plot_ly(
x = x,
y = y,
z = density1,
type = "surface",
colors = "viridis",
opacity = 0.5
)|> add_surface(
x = x,
y = y,
z = density3,
colors = "viridis",
opacity = 0.5
) |> add_markers(
data = dgp,
x = dgp$X1,
y = dgp$X2,
z = 0,
opacity=1,
color = ~prd
) |> add_markers(
x = grid$X1,
y = grid$X2,
z = 0,
color=~prd,
opacity=0.01
)
plot1
library(klaR)
library(mvtnorm)
set.seed(231354)
sigma1 <- matrix(c(1, 0, 0, 1), 2, 2, byrow = TRUE)
mu1 <- c(0, 0)
mu2 <- c(0, 2)
# Generate 2D MVN data from 1 group so one MVN
group1 <- data.frame(rmvnorm(100, mean = mu1, sigma = sigma1))
# Generate more 2D MVN from a different dist, that's group 2.
group2 <- data.frame(rmvnorm(100, mean = mu2, sigma = sigma1))
groups <- c(rep("G1", 100), rep("G2", 100))
dgp <-
data.frame(
"G" = groups,
"X1" = c(group1$X1, group2$X1),
"X2" = c(group1$X2, group2$X2)
)
# Now I can plot the underlying densities that generated them (this is not the same thing as plotting the points). Make the densities see through
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
grid <- expand.grid(x = x, y = y)
colnames(grid) <- colnames(xdat)[-1]
# Calculate the probability density for each point on the grid for both Gaussians
pdf_values1 <- dmvnorm(grid, mean = mu1, sigma = sigma1)
pdf_values2 <- dmvnorm(grid, mean = mu2, sigma = sigma1)
# Reshape the density values to match the grid
density1 <- matrix(pdf_values1, nrow = length(x))
density2 <- matrix(pdf_values2, nrow = length(x))
lda.out <- lda(G~.,dgp)
prd = as.numeric(predict(lda.out, newdata = grid)$class)
plot1 <-
plot_ly(
x = x,
y = y,
z = density1,
type = "surface",
colors = "viridis",
opacity = 0.5
)|> add_surface(
x = x,
y = y,
z = density3,
colors = "viridis",
opacity = 0.5
) |> add_markers(
data = dgp,
x = dgp$X1,
y = dgp$X2,
z = 0,
opacity=1,
color = ~dgp$G
) |> add_markers(
x = grid$X1,
y = grid$X2,
z = 0,
color=~prd,
opacity=0.01
)
plot1
runApp()
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
grid <- expand.grid(x = x, y = y)
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
grid <- expand.grid(x = x, y = y)
grid
runApp()
# Population Params
sigma1 <- matrix(c(1, 0, 0, 1), 2, 2, byrow = TRUE)
# mu1 <- c(input$sld1x, input$sld1y)
# mu2 <- c(input$sld2x, input$sld2y)
mu1 <- mu2 <- c(0,0)
# DGP
group1 <- data.frame(rmvnorm(100, mean = mu1, sigma = sigma1))
group2 <- data.frame(rmvnorm(100, mean = mu2, sigma = sigma1))
groups <- c(rep("G1", 100), rep("G2", 100))
dgp <-
data.frame(
"G" = groups,
"X1" = c(group1$X1, group2$X1),
"X2" = c(group1$X2, group2$X2)
)
# Set up grid
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
grid <- expand.grid(x = x, y = y)
# Calculate densities values for dists
pdf_values1 <- dmvnorm(grid, mean = mu1, sigma = sigma1)
pdf_values2 <- dmvnorm(grid, mean = mu2, sigma = sigma1)
# Reshape the density values to match the grid
density1 <- matrix(pdf_values1, nrow = length(x))
density2 <- matrix(pdf_values2, nrow = length(x))
# Fit LDA model
lda.out <- lda(G~.,dgp)
# Get grid predictions
prd = as.numeric(predict(lda.out, newdata = grid)$class)
grid
colnames(grid) <- c("X1,"X2")
colnames(grid) <- c("X1","X2")
# Get grid predictions
prd = as.numeric(predict(lda.out, newdata = grid)$class)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
knitr::opts_chunk$set(echo = TRUE)
library(plotly)
library(klaR)
library(mvtnorm)
library(klaR)
library(mvtnorm)
set.seed(231354)
sigma1 <- matrix(c(1, 0, 0, 1), 2, 2, byrow = TRUE)
mu1 <- c(0, 0)
mu2 <- c(0, 2)
# Generate 2D MVN data from 1 group so one MVN
group1 <- data.frame(rmvnorm(100, mean = mu1, sigma = sigma1))
# Generate more 2D MVN from a different dist, that's group 2.
group2 <- data.frame(rmvnorm(100, mean = mu2, sigma = sigma1))
groups <- c(rep("G1", 100), rep("G2", 100))
dgp <-
data.frame(
"G" = groups,
"X1" = c(group1$X1, group2$X1),
"X2" = c(group1$X2, group2$X2)
)
# Now I can plot the underlying densities that generated them (this is not the same thing as plotting the points). Make the densities see through
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
grid <- expand.grid(x = x, y = y)
colnames(grid) <- colnames(xdat)[-1]
library(MASS)
mydata <-
structure(
list(
Group = c(
"a",
"a",
"a",
"a",
"a",
"a",
"a",
"a",
"b",
"b",
"b",
"b",
"b",
"b",
"b",
"b",
"c",
"c",
"c",
"c",
"c",
"c",
"c",
"c"
),
Var1 = c(
7.5,
6.9,
6.5,
7.3,
8.1,
8,
7.4,
7.8,
8.3,
8.7,
8.9,
9.3,
8.5,
9.6,
9.8,
9.7,
11.2,
10.9,
11.5,
12,
11,
11.6,
11.7,
11.3
),
Var2 = c(
-6.5,
-6.2,
-6.7,
-6.9,
-7.1,-8,
-6.5,
-6.3,
-9.3,
-9.5,
-9.6,
-9.1,
-8.9,
-8.7,
-9.9,
-10,-6.7,
-6.4,
-6.8,
-6.1,
-7.1,
-8,
-6.9,
-6.6
)
),
.Names = c("Group",
"Var1", "Var2"),
class = "data.frame",
row.names = c(NA,-24L)
)
np <- 300
nd.x = seq(
from = min(mydata$Var1),
to = max(mydata$Var1),
length.out = np
)
nd.y = seq(
from = min(mydata$Var2),
to = max(mydata$Var2),
length.out = np
)
nd = expand.grid(Var1 = nd.x, Var2 = nd.y)
#run lda and predict using new data
new.lda = lda(Group ~ Var1 + Var2, data = mydata)
prd = as.numeric(predict(new.lda, newdata = nd)$class)
#create LD sequences from min - max values
p = predict(new.lda, newdata = nd)
p.x = seq(from = min(p$x[, 1]),
to = max(p$x[, 1]),
length.out = np) #LD1 scores
p.y = seq(from = min(p$x[, 2]),
to = max(p$x[, 2]),
length.out = np) #LD2 scores
# notice I don't use t.lda for first variable
plot(
new.lda,
panel = function(x, y, ...) {
points(x, y, ...)
},
col = c(4, 2, 3)[factor(mydata$Group)],
pch = c(17, 19, 15)[factor(mydata$Group)],
ylim = c(-3, 3),
xlim = c(-5, 5)
)
contour(
x = p.x,
y = p.y,
z = matrix(prd, nrow = np, ncol = np),
levels = c(1, 2, 3),
add = TRUE,
drawlabels = FALSE
)
library(klaR)
library(mvtnorm)
library(plotly)
set.seed(231354)
# DGP
mu1 <- c(0,0)
sigma1 <- matrix(c(1, 0, 0, 1), 2, 2, byrow=TRUE)
mu2 <- c(2,0)
sigma2 <- matrix(c(1, 0, 0, 1), 2, 2, byrow=TRUE)
# Simulate data
g1 <- rmvnorm(100, mean=mu1, sigma=sigma1)
g2 <- rmvnorm(100, mean=mu2, sigma=sigma2)
xdat <- cbind(data.frame("G" = c(rep("G1",100),rep("G2",100))),data.frame(rbind(g1, g2)))
# Fit LDA
lda.out <- lda(G~.,xdat)
# Get decision boundary TODO might have to solve for this instead
x <- seq(-5, 5, length.out = 100)
y <- seq(-5, 5, length.out = 100)
grid <- expand.grid(x = x, y = y)
colnames(grid) <- colnames(xdat)[-1]
lda.pred <- predict(lda.out,grid)
# Save prediction data
pred.data <- data.frame("G" = lda.pred$class, "X1" = grid$X1, "X2" = grid$X2)
# Calculate the probability density for each point on the grid for both Gaussians
pdf_values1 <- dmvnorm(grid, mean = mu1, sigma = sigma1)
pdf_values2 <- dmvnorm(grid, mean = mu2, sigma = sigma2)
# Reshape the density values to match the grid
density1 <- matrix(pdf_values1, nrow = length(x))
density2 <- matrix(pdf_values2, nrow = length(x))
# Make plane data (z = x + y)
plot_x_y_z <- data.frame("x" = pred.data$X1, "y" = pred.data$X2, "z" = pred.data$X1 + pred.data$X2, "G" = pred.data$G)
plot_x_y_z <- subset(plot_x_y_z, z <= 0.3 & z >=0) # Don't want plane values that violate probability
# Create a 3D surface plot for the first Gaussian density
plot1 <-
plot_ly(
x = x,
y = y,
z = density1,
type = "surface",
colors = "viridis"
)
# Add a 3D surface plot for the second Gaussian density with a different color
plot2 <-
add_surface(
plot1,
x = x,
y = y,
z = density2,
colors = "jet"
)
# Label plot
plot2 <- plot2 %>%
layout(scene = list(
zaxis = list(title = "Density"),
xaxis = list(title = "X"),
yaxis = list(title = "Y")
),
title = "Intersecting Gaussian Distributions")
opacity = 0.1
# Display the plot
plot2
library(shiny)
library(plotly)
library(klaR)
library(mvtnorm)
set.seed(231354)
?qda
runApp('app2.R')
runApp('app2.R')
runApp()
library(shinyMatrix)
install.packages("shinyMatrix")
library(shinyMatrix)
runApp()
runApp('app2.R')
runApp('app2.R')
runApp('app2.R')
runApp('app2.R')
library(shiny)
library(plotly)
library(klaR)
library(mvtnorm)
library(shinyMatrix)
?rda
runApp('app3.R')
library(shiny); runApp('app3.R')
install.packages("shiny.fluent")
library(shiny.fluent)
runApp('app3.R')
shiny.fluent::runExample("dashboard")
install.packages"shiny.router"
install.packages("shiny.router")
shiny.fluent::runExample("dashboard")
runApp('app3.R')
